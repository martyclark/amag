{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "title"
   },
   "source": [
    "# AMAG Car Scraper - Advanced Web Scraping for Swiss Car Subscriptions\n",
    "\n",
    "This notebook scrapes car subscription data from AMAG (auto.amag.ch) with advanced filtering capabilities.\n",
    "\n",
    "**Features:**\n",
    "- Multiple scraping methods (API detection, Selenium fallback)\n",
    "- Comprehensive filtering options\n",
    "- Data export to CSV\n",
    "- Statistical analysis and visualization\n",
    "- Respectful scraping with rate limiting"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "install"
   },
   "source": [
    "## 1. Install Required Packages"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "install_packages"
   },
   "outputs": [],
   "source": [
    "# Install required packages for Google Colab\n",
    "!pip install requests beautifulsoup4 pandas selenium webdriver-manager plotly seaborn -q\n",
    "\n",
    "# For Colab - install Chrome and ChromeDriver\n",
    "!apt-get update -qq\n",
    "!apt-get install -y -qq chromium-browser\n",
    "!pip install webdriver-manager -q\n",
    "\n",
    "print(\"‚úÖ All packages installed successfully!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "imports"
   },
   "source": [
    "## 2. Import Libraries and Setup"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "import_libraries"
   },
   "outputs": [],
   "source": [
    "import requests\n",
    "from bs4 import BeautifulSoup\n",
    "import json\n",
    "import pandas as pd\n",
    "import time\n",
    "import re\n",
    "from typing import List, Dict, Optional\n",
    "from urllib.parse import urljoin, urlparse\n",
    "import logging\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "# Visualization libraries\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import plotly.express as px\n",
    "import plotly.graph_objects as go\n",
    "from plotly.subplots import make_subplots\n",
    "\n",
    "# Selenium imports\n",
    "from selenium import webdriver\n",
    "from selenium.webdriver.chrome.options import Options\n",
    "from selenium.webdriver.common.by import By\n",
    "from selenium.webdriver.support.ui import WebDriverWait\n",
    "from selenium.webdriver.support import expected_conditions as EC\n",
    "from selenium.common.exceptions import TimeoutException\n",
    "from webdriver_manager.chrome import ChromeDriverManager\n",
    "from selenium.webdriver.chrome.service import Service\n",
    "\n",
    "# Setup plotting style\n",
    "plt.style.use('default')\n",
    "sns.set_palette(\"husl\")\n",
    "\n",
    "print(\"‚úÖ Libraries imported successfully!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "scraper_class"
   },
   "source": [
    "## 3. AMAG Advanced Scraper Class"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "scraper"
   },
   "outputs": [],
   "source": [
    "class AMAGAdvancedScraper:\n",
    "    def __init__(self, use_selenium=False, delay=1):\n",
    "        self.base_url = \"https://auto.amag.ch\"\n",
    "        self.delay = delay\n",
    "        self.use_selenium = use_selenium\n",
    "        self.driver = None\n",
    "        \n",
    "        # Setup requests session\n",
    "        self.session = requests.Session()\n",
    "        self.session.headers.update({\n",
    "            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n",
    "            'Accept': 'application/json, text/plain, */*',\n",
    "            'Accept-Language': 'en-US,en;q=0.5',\n",
    "            'Referer': 'https://auto.amag.ch/',\n",
    "        })\n",
    "        \n",
    "        # Setup logging for Colab\n",
    "        logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')\n",
    "        self.logger = logging.getLogger(__name__)\n",
    "        \n",
    "        if use_selenium:\n",
    "            self.setup_selenium()\n",
    "    \n",
    "    def setup_selenium(self):\n",
    "        \"\"\"Setup Selenium WebDriver for Colab environment\"\"\"\n",
    "        try:\n",
    "            chrome_options = Options()\n",
    "            chrome_options.add_argument('--headless')\n",
    "            chrome_options.add_argument('--no-sandbox')\n",
    "            chrome_options.add_argument('--disable-dev-shm-usage')\n",
    "            chrome_options.add_argument('--disable-gpu')\n",
    "            chrome_options.add_argument('--window-size=1920,1080')\n",
    "            chrome_options.add_argument('--disable-extensions')\n",
    "            chrome_options.add_argument('--disable-plugins')\n",
    "            \n",
    "            # Use webdriver-manager for Colab\n",
    "            service = Service(ChromeDriverManager().install())\n",
    "            self.driver = webdriver.Chrome(service=service, options=chrome_options)\n",
    "            \n",
    "            print(\"‚úÖ Selenium WebDriver initialized successfully!\")\n",
    "            \n",
    "        except Exception as e:\n",
    "            self.logger.error(f\"Failed to initialize Selenium: {e}\")\n",
    "            self.logger.info(\"Falling back to requests-only mode\")\n",
    "            self.use_selenium = False\n",
    "    \n",
    "    def search_for_api_endpoints(self):\n",
    "        \"\"\"Attempt to find API endpoints by examining network requests\"\"\"\n",
    "        print(\"üîç Searching for API endpoints...\")\n",
    "        \n",
    "        possible_endpoints = [\n",
    "            \"/api/vehicles\",\n",
    "            \"/api/search\",\n",
    "            \"/api/cars\",\n",
    "            \"/de/api/vehicles\",\n",
    "            \"/vehicles/search\",\n",
    "            \"/search/vehicles\",\n",
    "            \"/api/v1/vehicles\",\n",
    "            \"/api/v2/vehicles\"\n",
    "        ]\n",
    "        \n",
    "        for endpoint in possible_endpoints:\n",
    "            url = urljoin(self.base_url, endpoint)\n",
    "            try:\n",
    "                response = self.session.get(url, params={\n",
    "                    'only_abo_vehicle': '1',\n",
    "                    'page': 1,\n",
    "                    'limit': 24\n",
    "                }, timeout=10)\n",
    "                \n",
    "                if response.status_code == 200:\n",
    "                    try:\n",
    "                        data = response.json()\n",
    "                        if isinstance(data, dict) and ('vehicles' in data or 'cars' in data or 'results' in data):\n",
    "                            print(f\"‚úÖ Found API endpoint: {url}\")\n",
    "                            return url\n",
    "                    except json.JSONDecodeError:\n",
    "                        continue\n",
    "                        \n",
    "            except Exception as e:\n",
    "                continue\n",
    "        \n",
    "        print(\"‚ùå No API endpoints found\")\n",
    "        return None\n",
    "    \n",
    "    def scrape_basic_html(self, max_pages: int = 10) -> List[Dict]:\n",
    "        \"\"\"Basic HTML scraping fallback method\"\"\"\n",
    "        print(\"üåê Using basic HTML scraping...\")\n",
    "        all_cars = []\n",
    "        \n",
    "        for page in range(1, max_pages + 1):\n",
    "            print(f\"üìÑ Scraping page {page}...\", end=\" \")\n",
    "            \n",
    "            url = f\"{self.base_url}/de\"\n",
    "            params = {\n",
    "                'only_abo_vehicle': '1',\n",
    "                'page': page,\n",
    "                'limit': '24',\n",
    "                'sort': 'ID_DESC'\n",
    "            }\n",
    "            \n",
    "            try:\n",
    "                response = self.session.get(url, params=params, timeout=15)\n",
    "                response.raise_for_status()\n",
    "                \n",
    "                soup = BeautifulSoup(response.content, 'html.parser')\n",
    "                cars = self.extract_car_data_html(soup)\n",
    "                \n",
    "                if not cars:\n",
    "                    print(\"No cars found, stopping\")\n",
    "                    break\n",
    "                \n",
    "                all_cars.extend(cars)\n",
    "                print(f\"‚úÖ Found {len(cars)} cars\")\n",
    "                \n",
    "                time.sleep(self.delay)\n",
    "                \n",
    "            except Exception as e:\n",
    "                print(f\"‚ùå Error: {e}\")\n",
    "                continue\n",
    "        \n",
    "        return all_cars\n",
    "    \n",
    "    def extract_car_data_html(self, soup: BeautifulSoup) -> List[Dict]:\n",
    "        \"\"\"Extract car data from HTML\"\"\"\n",
    "        cars = []\n",
    "        \n",
    "        # Look for price indicators first to find car containers\n",
    "        price_elements = soup.find_all(text=re.compile(r'CHF\\s*[\\d\\'.,]+'))\n",
    "        \n",
    "        for price_element in price_elements:\n",
    "            # Find the container for this price\n",
    "            container = price_element.parent\n",
    "            for _ in range(5):  # Go up a few levels to find the main container\n",
    "                if container and container.parent:\n",
    "                    container = container.parent\n",
    "                else:\n",
    "                    break\n",
    "            \n",
    "            if container:\n",
    "                car_data = self.extract_single_car_advanced(container)\n",
    "                if car_data and car_data not in cars:\n",
    "                    cars.append(car_data)\n",
    "        \n",
    "        return cars[:24]  # Limit to expected page size\n",
    "    \n",
    "    def extract_single_car_advanced(self, container) -> Optional[Dict]:\n",
    "        \"\"\"Advanced single car extraction\"\"\"\n",
    "        car = {}\n",
    "        \n",
    "        # Get all text for analysis\n",
    "        all_text = container.get_text().strip()\n",
    "        \n",
    "        # Price extraction with multiple patterns\n",
    "        price_patterns = [\n",
    "            r'CHF\\s*([\\d\\',.']+)',\n",
    "            r'([\\d\\',.']+)\\s*CHF',\n",
    "            r'Fr\\.\\s*([\\d\\',.']+)',\n",
    "            r'([\\d\\',.']+)\\s*Fr\\.'\n",
    "        ]\n",
    "        \n",
    "        for pattern in price_patterns:\n",
    "            match = re.search(pattern, all_text)\n",
    "            if match:\n",
    "                try:\n",
    "                    price_str = match.group(1).replace(\"'\", \"\").replace(\",\", \"\").replace(\".\", \"\")\n",
    "                    car['monthly_price'] = int(price_str)\n",
    "                    break\n",
    "                except ValueError:\n",
    "                    continue\n",
    "        \n",
    "        # Fuel type detection\n",
    "        fuel_types = {\n",
    "            'elektrisch': 'Electric',\n",
    "            'electric': 'Electric',\n",
    "            'diesel': 'Diesel',\n",
    "            'benzin': 'Petrol',\n",
    "            'petrol': 'Petrol',\n",
    "            'hybrid': 'Hybrid',\n",
    "            'mhev': 'Mild Hybrid',\n",
    "            'phev': 'Plug-in Hybrid'\n",
    "        }\n",
    "        \n",
    "        for keyword, fuel_type in fuel_types.items():\n",
    "            if keyword.lower() in all_text.lower():\n",
    "                car['fuel_type'] = fuel_type\n",
    "                break\n",
    "        \n",
    "        # Transmission detection\n",
    "        if 'automatik' in all_text.lower() or 'automatic' in all_text.lower():\n",
    "            car['transmission'] = 'Automatic'\n",
    "        elif 'schaltgetriebe' in all_text.lower() or 'manual' in all_text.lower():\n",
    "            car['transmission'] = 'Manual'\n",
    "        elif 'dsg' in all_text.lower():\n",
    "            car['transmission'] = 'DSG'\n",
    "        \n",
    "        # Extract title from various sources\n",
    "        title_elem = (container.find(['h1', 'h2', 'h3', 'h4']) or \n",
    "                     container.find(class_=re.compile(r'title|name|model', re.I)) or\n",
    "                     container.find('a'))\n",
    "        \n",
    "        if title_elem:\n",
    "            car['title'] = title_elem.get_text().strip()[:100]  # Limit length\n",
    "        \n",
    "        # Extract link\n",
    "        link_elem = container.find('a', href=True)\n",
    "        if link_elem:\n",
    "            car['detail_url'] = urljoin(self.base_url, link_elem['href'])\n",
    "        \n",
    "        # Extract image\n",
    "        img_elem = container.find('img', src=True)\n",
    "        if img_elem:\n",
    "            car['image_url'] = urljoin(self.base_url, img_elem['src'])\n",
    "        \n",
    "        return car if len(car) >= 2 else None  # At least 2 fields required\n",
    "    \n",
    "    def scrape_cars(self, max_pages: int = 10) -> List[Dict]:\n",
    "        \"\"\"Main scraping method that tries different approaches\"\"\"\n",
    "        cars = []\n",
    "        \n",
    "        print(\"üöÄ Starting AMAG car scraping...\")\n",
    "        print(f\"üìä Target: Up to {max_pages} pages\")\n",
    "        print(\"-\" * 50)\n",
    "        \n",
    "        # Method 1: Try to find API endpoint\n",
    "        api_url = self.search_for_api_endpoints()\n",
    "        \n",
    "        # Method 2: Basic HTML scraping (most reliable for this site)\n",
    "        if not cars:\n",
    "            cars = self.scrape_basic_html(max_pages)\n",
    "        \n",
    "        print(\"-\" * 50)\n",
    "        print(f\"‚úÖ Scraping completed! Found {len(cars)} cars total\")\n",
    "        \n",
    "        return cars\n",
    "    \n",
    "    def filter_cars(self, cars: List[Dict], filters: Dict) -> List[Dict]:\n",
    "        \"\"\"Enhanced filtering with more options\"\"\"\n",
    "        print(f\"üîç Applying filters: {filters}\")\n",
    "        \n",
    "        filtered_cars = cars.copy()\n",
    "        original_count = len(filtered_cars)\n",
    "        \n",
    "        # Price range filtering\n",
    "        if 'min_price' in filters:\n",
    "            filtered_cars = [c for c in filtered_cars \n",
    "                           if c.get('monthly_price', 0) >= filters['min_price']]\n",
    "            print(f\"   After min_price filter: {len(filtered_cars)} cars\")\n",
    "        \n",
    "        if 'max_price' in filters:\n",
    "            filtered_cars = [c for c in filtered_cars \n",
    "                           if c.get('monthly_price', float('inf')) <= filters['max_price']]\n",
    "            print(f\"   After max_price filter: {len(filtered_cars)} cars\")\n",
    "        \n",
    "        # Fuel type filtering\n",
    "        if 'fuel_types' in filters and filters['fuel_types']:\n",
    "            fuel_types = [f.lower() for f in filters['fuel_types']]\n",
    "            filtered_cars = [c for c in filtered_cars \n",
    "                           if c.get('fuel_type', '').lower() in fuel_types]\n",
    "            print(f\"   After fuel_type filter: {len(filtered_cars)} cars\")\n",
    "        \n",
    "        # Brand filtering\n",
    "        if 'brands' in filters and filters['brands']:\n",
    "            brands = [b.lower() for b in filters['brands']]\n",
    "            filtered_cars = [c for c in filtered_cars \n",
    "                           if any(brand in c.get('title', '').lower() for brand in brands)]\n",
    "            print(f\"   After brand filter: {len(filtered_cars)} cars\")\n",
    "        \n",
    "        # Transmission filtering\n",
    "        if 'transmissions' in filters and filters['transmissions']:\n",
    "            trans_types = [t.lower() for t in filters['transmissions']]\n",
    "            filtered_cars = [c for c in filtered_cars \n",
    "                           if c.get('transmission', '').lower() in trans_types]\n",
    "            print(f\"   After transmission filter: {len(filtered_cars)} cars\")\n",
    "        \n",
    "        print(f\"üéØ Final result: {len(filtered_cars)}/{original_count} cars match criteria\")\n",
    "        return filtered_cars\n",
    "    \n",
    "    def close(self):\n",
    "        \"\"\"Clean up resources\"\"\"\n",
    "        if self.driver:\n",
    "            self.driver.quit()\n",
    "            print(\"üîÑ Selenium driver closed\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "analysis_functions"
   },
   "source": [
    "## 4. Data Analysis and Visualization Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "analysis"
   },
   "outputs": [],
   "source": [
    "def analyze_cars(df):\n",
    "    \"\"\"Perform comprehensive analysis of car data\"\"\"\n",
    "    print(\"üìä AMAG Car Data Analysis\")\n",
    "    print(\"=\" * 50)\n",
    "    \n",
    "    # Basic statistics\n",
    "    print(f\"üìà Dataset Overview:\")\n",
    "    print(f\"   Total cars: {len(df)}\")\n",
    "    \n",
    "    if 'monthly_price' in df.columns:\n",
    "        prices = df['monthly_price'].dropna()\n",
    "        if len(prices) > 0:\n",
    "            print(f\"   Price range: CHF {prices.min()} - CHF {prices.max()}\")\n",
    "            print(f\"   Average price: CHF {prices.mean():.0f}\")\n",
    "            print(f\"   Median price: CHF {prices.median():.0f}\")\n",
    "    \n",
    "    # Fuel type distribution\n",
    "    if 'fuel_type' in df.columns:\n",
    "        print(f\"\\n‚õΩ Fuel Type Distribution:\")\n",
    "        fuel_counts = df['fuel_type'].value_counts()\n",
    "        for fuel, count in fuel_counts.items():\n",
    "            percentage = (count / len(df)) * 100\n",
    "            print(f\"   {fuel}: {count} cars ({percentage:.1f}%)\")\n",
    "    \n",
    "    # Transmission distribution\n",
    "    if 'transmission' in df.columns:\n",
    "        print(f\"\\n‚öôÔ∏è  Transmission Distribution:\")\n",
    "        trans_counts = df['transmission'].value_counts()\n",
    "        for trans, count in trans_counts.items():\n",
    "            percentage = (count / len(df)) * 100\n",
    "            print(f\"   {trans}: {count} cars ({percentage:.1f}%)\")\n",
    "    \n",
    "    return df.describe()\n",
    "\n",
    "def create_visualizations(df):\n",
    "    \"\"\"Create comprehensive visualizations\"\"\"\n",
    "    \n",
    "    # Create subplots\n",
    "    fig = make_subplots(\n",
    "        rows=2, cols=2,\n",
    "        subplot_titles=('Price Distribution', 'Fuel Type Distribution', \n",
    "                       'Price by Fuel Type', 'Transmission Types'),\n",
    "        specs=[[{\"secondary_y\": False}, {\"type\": \"pie\"}],\n",
    "               [{\"secondary_y\": False}, {\"type\": \"pie\"}]]\n",
    "    )\n",
    "    \n",
    "    # 1. Price Distribution Histogram\n",
    "    if 'monthly_price' in df.columns:\n",
    "        prices = df['monthly_price'].dropna()\n",
    "        fig.add_trace(\n",
    "            go.Histogram(x=prices, name=\"Price Distribution\", nbinsx=20),\n",
    "            row=1, col=1\n",
    "        )\n",
    "    \n",
    "    # 2. Fuel Type Pie Chart\n",
    "    if 'fuel_type' in df.columns:\n",
    "        fuel_counts = df['fuel_type'].value_counts()\n",
    "        fig.add_trace(\n",
    "            go.Pie(labels=fuel_counts.index, values=fuel_counts.values, name=\"Fuel Types\"),\n",
    "            row=1, col=2\n",
    "        )\n",
    "    \n",
    "    # 3. Price by Fuel Type Box Plot\n",
    "    if 'monthly_price' in df.columns and 'fuel_type' in df.columns:\n",
    "        for fuel_type in df['fuel_type'].unique():\n",
    "            if pd.notna(fuel_type):\n",
    "                fuel_prices = df[df['fuel_type'] == fuel_type]['monthly_price'].dropna()\n",
    "                if len(fuel_prices) > 0:\n",
    "                    fig.add_trace(\n",
    "                        go.Box(y=fuel_prices, name=fuel_type),\n",
    "                        row=2, col=1\n",
    "                    )\n",
    "    \n",
    "    # 4. Transmission Type Pie Chart\n",
    "    if 'transmission' in df.columns:\n",
    "        trans_counts = df['transmission'].value_counts()\n",
    "        fig.add_trace(\n",
    "            go.Pie(labels=trans_counts.index, values=trans_counts.values, name=\"Transmission\"),\n",
    "            row=2, col=2\n",
    "        )\n",
    "    \n",
    "    # Update layout\n",
    "    fig.update_layout(\n",
    "        title_text=\"AMAG Car Subscription Analysis Dashboard\",\n",
    "        title_x=0.5,\n",
    "        height=800,\n",
    "        showlegend=True\n",
    "    )\n",
    "    \n",
    "    # Update axis labels\n",
    "    fig.update_xaxes(title_text=\"Monthly Price (CHF)\", row=1, col=1)\n",
    "    fig.update_yaxes(title_text=\"Number of Cars\", row=1, col=1)\n",
    "    fig.update_yaxes(title_text=\"Monthly Price (CHF)\", row=2, col=1)\n",
    "    \n",
    "    return fig\n",
    "\n",
    "def export_data(df, filename_prefix=\"amag_cars\"):\n",
    "    \"\"\"Export data to various formats\"\"\"\n",
    "    timestamp = pd.Timestamp.now().strftime(\"%Y%m%d_%H%M%S\")\n",
    "    \n",
    "    # Export to CSV\n",
    "    csv_filename = f\"{filename_prefix}_{timestamp}.csv\"\n",
    "    df.to_csv(csv_filename, index=False, encoding='utf-8')\n",
    "    print(f\"üìÑ Exported to CSV: {csv_filename}\")\n",
    "    \n",
    "    return csv_filename\n",
    "\n",
    "def display_sample_cars(df, n=5):\n",
    "    \"\"\"Display sample cars in a nice format\"\"\"\n",
    "    print(f\"\\nüöó Sample Car Listings (showing {min(n, len(df))} cars):\")\n",
    "    print(\"=\" * 80)\n",
    "    \n",
    "    for i, (idx, car) in enumerate(df.head(n).iterrows()):\n",
    "        print(f\"\\nüîπ Car #{i+1}:\")\n",
    "        \n",
    "        if 'title' in car and pd.notna(car['title']):\n",
    "            print(f\"   Model: {car['title']}\")\n",
    "        \n",
    "        if 'monthly_price' in car and pd.notna(car['monthly_price']):\n",
    "            print(f\"   üí∞ Price: CHF {car['monthly_price']}/month\")\n",
    "        \n",
    "        if 'fuel_type' in car and pd.notna(car['fuel_type']):\n",
    "            print(f\"   ‚õΩ Fuel: {car['fuel_type']}\")\n",
    "        \n",
    "        if 'transmission' in car and pd.notna(car['transmission']):\n",
    "            print(f\"   ‚öôÔ∏è  Transmission: {car['transmission']}\")\n",
    "        \n",
    "        if 'detail_url' in car and pd.notna(car['detail_url']):\n",
    "            print(f\"   üîó Link: {car['detail_url']}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "config"
   },
   "source": [
    "## 5. Configuration and Setup"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "configuration"
   },
   "outputs": [],
   "source": [
    "    # Configuration settings\n",
    "CONFIG = {\n",
    "    'MAX_PAGES': 5,           # Number of pages to scrape\n",
    "    'USE_SELENIUM': False,    # Set to True if basic scraping fails\n",
    "    'DELAY_SECONDS': 1,       # Delay between requests (be respectful!)\n",
    "    'ENABLE_VISUALIZATIONS': True,\n",
    "    'EXPORT_DATA': True\n",
    "}\n",
    "\n",
    "# Filter settings - customize these based on your needs\n",
    "FILTERS = {\n",
    "    'min_price': 400,         # Minimum CHF per month\n",
    "    'max_price': 1500,        # Maximum CHF per month\n",
    "    'fuel_types': [],         # Leave empty for all, or specify: ['Electric', 'Hybrid']\n",
    "    'transmissions': [],      # Leave empty for all, or specify: ['Automatic']\n",
    "    'brands': []              # Leave empty for all, or specify: ['audi', 'bmw', 'tesla']\n",
    "}\n",
    "\n",
    "print(\"‚öôÔ∏è Configuration loaded:\")\n",
    "print(f\"   Max pages: {CONFIG['MAX_PAGES']}\")\n",
    "print(f\"   Use Selenium: {CONFIG['USE_SELENIUM']}\")\n",
    "print(f\"   Delay: {CONFIG['DELAY_SECONDS']} seconds\")\n",
    "  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {\n    \"id\": \"main_execution\"\n   },\n   \"source\": [\n    \"## 6. Main Scraping Execution\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"id\": \"scraping_execution\"\n   },\n   \"outputs\": [],\n   \"source\": [\n    \"# Initialize the scraper\\n\",\n    \"print(\\\"üöÄ Initializing AMAG Advanced Scraper...\\\")\\n\",\n    \"scraper = AMAGAdvancedScraper(\\n\",\n    \"    use_selenium=CONFIG['USE_SELENIUM'], \\n\",\n    \"    delay=CONFIG['DELAY_SECONDS']\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"# Scrape the cars\\n\",\n    \"try:\\n\",\n    \"    print(\\\"\\\\n\\\" + \\\"=\\\"*60)\\n\",\n    \"    print(\\\"üéØ STARTING AMAG CAR SCRAPING\\\")\\n\",\n    \"    print(\\\"=\\\"*60)\\n\",\n    \"    \\n\",\n    \"    cars_data = scraper.scrape_cars(max_pages=CONFIG['MAX_PAGES'])\\n\",\n    \"    \\n\",\n    \"    if not cars_data:\\n\",\n    \"        print(\\\"‚ùå No cars found! This could mean:\\\")\\n\",\n    \"        print(\\\"   - Website structure has changed\\\")\\n\",\n    \"        print(\\\"   - Network issues\\\")\\n\",\n    \"        print(\\\"   - Anti-bot protection is active\\\")\\n\",\n    \"        print(\\\"\\\\nüí° Try setting USE_SELENIUM=True in the config above\\\")\\n\",\n    \"    else:\\n\",\n    \"        print(f\\\"\\\\nüéâ Successfully scraped {len(cars_data)} cars!\\\")\\n\",\n    \"        \\n\",\n    \"        # Convert to DataFrame for analysis\\n\",\n    \"        df_all = pd.DataFrame(cars_data)\\n\",\n    \"        print(f\\\"üìä Created DataFrame with {len(df_all)} rows and {len(df_all.columns)} columns\\\")\\n\",\n    \"        print(f\\\"üè∑Ô∏è  Columns: {', '.join(df_all.columns.tolist())}\\\")\\n\",\n    \"\\n\",\n    \"except Exception as e:\\n\",\n    \"    print(f\\\"‚ùå Scraping failed with error: {e}\\\")\\n\",\n    \"    import traceback\\n\",\n    \"    traceback.print_exc()\\n\",\n    \"    cars_data = []\\n\",\n    \"    df_all = pd.DataFrame()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {\n    \"id\": \"data_filtering\"\n   },\n   \"source\": [\n    \"## 7. Data Filtering and Analysis\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"id\": \"filtering_analysis\"\n   },\n   \"outputs\": [],\n   \"source\": [\n    \"if not df_all.empty:\\n\",\n    \"    # Display sample of raw data\\n\",\n    \"    print(\\\"\\\\n\\\" + \\\"=\\\"*60)\\n\",\n    \"    print(\\\"üìã RAW DATA PREVIEW\\\")\\n\",\n    \"    print(\\\"=\\\"*60)\\n\",\n    \"    display_sample_cars(df_all, n=3)\\n\",\n    \"    \\n\",\n    \"    # Apply filters if specified\\n\",\n    \"    active_filters = {k: v for k, v in FILTERS.items() if v}  # Only non-empty filters\\n\",\n    \"    \\n\",\n    \"    if active_filters:\\n\",\n    \"        print(f\\\"\\\\nüîç Applying filters: {active_filters}\\\")\\n\",\n    \"        filtered_cars = scraper.filter_cars(cars_data, active_filters)\\n\",\n    \"        df_filtered = pd.DataFrame(filtered_cars)\\n\",\n    \"        \\n\",\n    \"        print(f\\\"\\\\nüìä Filtered dataset: {len(df_filtered)} cars\\\")\\n\",\n    \"        if not df_filtered.empty:\\n\",\n    \"            display_sample_cars(df_filtered, n=5)\\n\",\n    \"    else:\\n\",\n    \"        print(\\\"\\\\nüìä No filters applied - using all data\\\")\\n\",\n    \"        df_filtered = df_all.copy()\\n\",\n    \"    \\n\",\n    \"    # Perform analysis\\n\",\n    \"    print(\\\"\\\\n\\\" + \\\"=\\\"*60)\\n\",\n    \"    print(\\\"üìà DATA ANALYSIS\\\")\\n\",\n    \"    print(\\\"=\\\"*60)\\n\",\n    \"    \\n\",\n    \"    if not df_filtered.empty:\\n\",\n    \"        stats = analyze_cars(df_filtered)\\n\",\n    \"        print(f\\\"\\\\nüìã Statistical Summary:\\\")\\n\",\n    \"        if 'monthly_price' in df_filtered.columns:\\n\",\n    \"            print(df_filtered['monthly_price'].describe())\\n\",\n    \"    else:\\n\",\n    \"        print(\\\"‚ùå No data available for analysis\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {\n    \"id\": \"visualization\"\n   },\n   \"source\": [\n    \"## 8. Data Visualization\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"id\": \"data_visualization\"\n   },\n   \"outputs\": [],\n   \"source\": [\n    \"if not df_filtered.empty and CONFIG['ENABLE_VISUALIZATIONS']:\\n\",\n    \"    print(\\\"\\\\n\\\" + \\\"=\\\"*60)\\n\",\n    \"    print(\\\"üìä CREATING VISUALIZATIONS\\\")\\n\",\n    \"    print(\\\"=\\\"*60)\\n\",\n    \"    \\n\",\n    \"    try:\\n\",\n    \"        # Create interactive dashboard\\n\",\n    \"        fig = create_visualizations(df_filtered)\\n\",\n    \"        fig.show()\\n\",\n    \"        \\n\",\n    \"        # Additional price analysis chart\\n\",\n    \"        if 'monthly_price' in df_filtered.columns:\\n\",\n    \"            print(\\\"üìà Creating additional price analysis...\\\")\\n\",\n    \"            \\n\",\n    \"            fig_price = px.histogram(\\n\",\n    \"                df_filtered, \\n\",\n    \"                x='monthly_price',\\n\",\n    \"                title='Monthly Price Distribution - AMAG Car Subscriptions',\\n\",\n    \"                labels={'monthly_price': 'Monthly Price (CHF)', 'count': 'Number of Cars'},\\n\",\n    \"                nbins=20\\n\",\n    \"            )\\n\",\n    \"            fig_price.update_layout(\\n\",\n    \"                title_x=0.5,\\n\",\n    \"                xaxis_title=\\\"Monthly Price (CHF)\\\",\\n\",\n    \"                yaxis_title=\\\"Number of Cars\\\"\\n\",\n    \"            )\\n\",\n    \"            fig_price.show()\\n\",\n    \"        \\n\",\n    \"        # Fuel type vs Price scatter plot\\n\",\n    \"        if 'fuel_type' in df_filtered.columns and 'monthly_price' in df_filtered.columns:\\n\",\n    \"            print(\\\"‚õΩ Creating fuel type analysis...\\\")\\n\",\n    \"            \\n\",\n    \"            fig_scatter = px.strip(\\n\",\n    \"                df_filtered,\\n\",\n    \"                x='fuel_type',\\n\",\n    \"                y='monthly_price',\\n\",\n    \"                title='Price Distribution by Fuel Type',\\n\",\n    \"                labels={'monthly_price': 'Monthly Price (CHF)', 'fuel_type': 'Fuel Type'}\\n\",\n    \"            )\\n\",\n    \"            fig_scatter.update_layout(title_x=0.5)\\n\",\n    \"            fig_scatter.show()\\n\",\n    \"            \\n\",\n    \"    except Exception as e:\\n\",\n    \"        print(f\\\"‚ùå Visualization error: {e}\\\")\\n\",\n    \"        print(\\\"üìä Falling back to simple matplotlib plots...\\\")\\n\",\n    \"        \\n\",\n    \"        try:\\n\",\n    \"            # Simple matplotlib fallback\\n\",\n    \"            if 'monthly_price' in df_filtered.columns:\\n\",\n    \"                plt.figure(figsize=(10, 6))\\n\",\n    \"                plt.hist(df_filtered['monthly_price'].dropna(), bins=20, alpha=0.7, color='skyblue')\\n\",\n    \"                plt.title('Monthly Price Distribution', fontsize=16)\\n\",\n    \"                plt.xlabel('Monthly Price (CHF)', fontsize=12)\\n\",\n    \"                plt.ylabel('Number of Cars', fontsize=12)\\n\",\n    \"                plt.grid(axis='y', alpha=0.3)\\n\",\n    \"                plt.show()\\n\",\n    \"                \\n\",\n    \"        except Exception as e2:\\n\",\n    \"            print(f\\\"‚ùå Fallback visualization also failed: {e2}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {\n    \"id\": \"data_export\"\n   },\n   \"source\": [\n    \"## 9. Data Export\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"id\": \"export_data\"\n   },\n   \"outputs\": [],\n   \"source\": [\n    \"if not df_filtered.empty and CONFIG['EXPORT_DATA']:\\n\",\n    \"    print(\\\"\\\\n\\\" + \\\"=\\\"*60)\\n\",\n    \"    print(\\\"üíæ EXPORTING DATA\\\")\\n\",\n    \"    print(\\\"=\\\"*60)\\n\",\n    \"    \\n\",\n    \"    try:\\n\",\n    \"        # Export filtered results\\n\",\n    \"        if len(df_filtered) > 0:\\n\",\n    \"            filename = export_data(df_filtered, \\\"amag_filtered_cars\\\")\\n\",\n    \"            print(f\\\"‚úÖ Filtered data exported: {filename}\\\")\\n\",\n    \"        \\n\",\n    \"        # Export all results if different from filtered\\n\",\n    \"        if not df_all.equals(df_filtered) and len(df_all) > 0:\\n\",\n    \"            filename_all = export_data(df_all, \\\"amag_all_cars\\\")\\n\",\n    \"            print(f\\\"‚úÖ All data exported: {filename_all}\\\")\\n\",\n    \"        \\n\",\n    \"        # Display download instructions\\n\",\n    \"        print(\\\"\\\\nüì• To download files in Colab:\\\")\\n\",\n    \"        print(\\\"   1. Click on the folder icon in the left sidebar\\\")\\n\",\n    \"        print(\\\"   2. Right-click on the CSV file you want\\n\",\n    \"        print(\\\"   3. Select 'Download'\\\")\\n\",\n    \"        \\n\",\n    \"    except Exception as e:\\n\",\n    \"        print(f\\\"‚ùå Export failed: {e}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {\n    \"id\": \"final_results\"\n   },\n   \"source\": [\n    \"## 10. Final Results and Recommendations\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"id\": \"final_summary\"\n   },\n   \"outputs\": [],\n   \"source\": [\n    \"print(\\\"\\\\n\\\" + \\\"=\\\"*60)\\n\",\n    \"print(\\\"üéØ FINAL RESULTS & RECOMMENDATIONS\\\")\\n\",\n    \"print(\\\"=\\\"*60)\\n\",\n    \"\\n\",\n    \"if not df_filtered.empty:\\n\",\n    \"    print(f\\\"‚úÖ Scraping successful!\\\")\\n\",\n    \"    print(f\\\"üìä Total cars found: {len(df_all)}\\\")\\n\",\n    \"    print(f\\\"üéØ Cars matching filters: {len(df_filtered)}\\\")\\n\",\n    \"    \\n\",\n    \"    if 'monthly_price' in df_filtered.columns:\\n\",\n    \"        prices = df_filtered['monthly_price'].dropna()\\n\",\n    \"        if len(prices) > 0:\\n\",\n    \"            print(f\\\"üí∞ Price range: CHF {prices.min()} - CHF {prices.max()}\\\")\\n\",\n    \"            print(f\\\"üí∞ Average price: CHF {prices.mean():.0f}\\\")\\n\",\n    \"    \\n\",\n    \"    # Show best deals (lowest prices)\\n\",\n    \"    if 'monthly_price' in df_filtered.columns and len(df_filtered) > 0:\\n\",\n    \"        print(f\\\"\\\\nüíé Best Deals (Top 5 lowest prices):\\\")\\n\",\n    \"        best_deals = df_filtered.nsmallest(5, 'monthly_price')\\n\",\n    \"        for i, (idx, car) in enumerate(best_deals.iterrows(), 1):\\n\",\n    \"            title = car.get('title', 'Unknown model')[:50]\\n\",\n    \"            price = car.get('monthly_price', 'N/A')\\n\",\n    \"            fuel = car.get('fuel_type', 'N/A')\\n\",\n    \"            print(f\\\"   {i}. {title} - CHF {price}/month ({fuel})\\\")\\n\",\n    \"    \\n\",\n    \"    # Recommendations for optimization\\n\",\n    \"    print(f\\\"\\\\nüîß Optimization Recommendations:\\\")\\n\",\n    \"    print(f\\\"   ‚Ä¢ Adjust MAX_PAGES to scrape more data (current: {CONFIG['MAX_PAGES']})\\\")\\n\",\n    \"    print(f\\\"   ‚Ä¢ Modify FILTERS to find specific cars you're interested in\\\")\\n\",\n    \"    print(f\\\"   ‚Ä¢ Set USE_SELENIUM=True if you need more comprehensive data\\\")\\n\",\n    \"    print(f\\\"   ‚Ä¢ Increase DELAY_SECONDS if you encounter rate limiting\\\")\\n\",\n    \"    \\n\",\n    \"else:\\n\",\n    \"    print(\\\"‚ùå No data was successfully scraped.\\\")\\n\",\n    \"    print(\\\"\\\\nüîß Troubleshooting steps:\\\")\\n\",\n    \"    print(\\\"   1. Check your internet connection\\\")\\n\",\n    \"    print(\\\"   2. Set USE_SELENIUM=True in the config\\\")\\n\",\n    \"    print(\\\"   3. Increase DELAY_SECONDS to avoid rate limiting\\\")\\n\",\n    \"    print(\\\"   4. Verify the AMAG website is accessible\\\")\\n\",\n    \"    print(\\\"   5. Check if website structure has changed\\\")\\n\",\n    \"\\n\",\n    \"# Cleanup\\n\",\n    \"try:\\n\",\n    \"    scraper.close()\\n\",\n    \"except:\\n\",\n    \"    pass\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\nüéâ AMAG Car Scraper execution completed!\\\")\\n\",\n    \"print(\\\"=\\\" * 60)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {\n    \"id\": \"custom_analysis\"\n   },\n   \"source\": [\n    \"## 11. Custom Analysis Functions\\n\",\n    \"\\n\",\n    \"Use these cells to perform custom analysis on your scraped data:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"id\": \"electric_deals\"\n   },\n   \"outputs\": [],\n   \"source\": [\n    \"# Custom analysis cell - modify as needed\\n\",\n    \"def find_best_electric_deals(df, max_price=1000):\\n\",\n    \"    \\\"\\\"\\\"Find the best electric car deals under a certain price\\\"\\\"\\\"\\n\",\n    \"    if 'fuel_type' in df.columns and 'monthly_price' in df.columns:\\n\",\n    \"        electric_cars = df[\\n\",\n    \"            (df['fuel_type'].str.contains('Electric|electric', na=False)) &\\n\",\n    \"            (df['monthly_price'] <= max_price)\\n\",\n    \"        ].sort_values('monthly_price')\\n\",\n    \"        \\n\",\n    \"        print(f\\\"üîã Best Electric Car Deals (under CHF {max_price}):\\\")\\n\",\n    \"        for i, (idx, car) in enumerate(electric_cars.head(10).iterrows(), 1):\\n\",\n    \"            title = car.get('title', 'Unknown')[:60]\\n\",\n    \"            price = car.get('monthly_price', 'N/A')\\n\",\n    \"            print(f\\\"   {i}. {title} - CHF {price}/month\\\")\\n\",\n    \"        \\n\",\n    \"        return electric_cars\\n\",\n    \"    else:\\n\",\n    \"        print(\\\"‚ùå Required columns not found\\\")\\n\",\n    \"        return pd.DataFrame()\\n\",\n    \"\\n\",\n    \"# Run custom analysis if data is available\\n\",\n    \"if 'df_filtered' in locals() and not df_filtered.empty:\\n\",\n    \"    electric_deals = find_best_electric_deals(df_filtered, max_price=1200)\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"id\": \"fuel_comparison\"\n   },\n   \"outputs\": [],\n   \"source\": [\n    \"# Another custom analysis example\\n\",\n    \"def compare_fuel_types(df):\\n\",\n    \"    \\\"\\\"\\\"Compare average prices by fuel type\\\"\\\"\\\"\\n\",\n    \"    if 'fuel_type' in df.columns and 'monthly_price' in df.columns:\\n\",\n    \"        fuel_analysis = df.groupby('fuel_type')['monthly_price'].agg(['mean', 'min', 'max', 'count']).round(0)\\n\",\n    \"        fuel_analysis.columns = ['Average Price', 'Min Price', 'Max Price', 'Number of Cars']\\n\",\n    \"        \\n\",\n    \"        print(\\\"‚õΩ Fuel Type Comparison:\\\")\\n\",\n    \"        print(fuel_analysis.sort_values('Average Price'))\\n\",\n    \"        \\n\",\n    \"        return fuel_analysis\\n\",\n    \"    else:\\n\",\n    \"        print(\\\"‚ùå Required columns not found\\\")\\n\",\n    \"        return pd.DataFrame()\\n\",\n    \"\\n\",\n    \"# Run fuel type comparison if data is available\\n\",\n    \"if 'df_filtered' in locals() and not df_filtered.empty:\\n\",\n    \"    fuel_comparison = compare_fuel_types(df_filtered)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {\n    \"id\": \"notes\"\n   },\n   \"source\": [\n    \"## üìù Notes and Tips\\n\",\n    \"\\n\",\n    \"### Usage Tips:\\n\",\n    \"- **Adjust filters** in cell 5 to find cars matching your criteria\\n\",\n    \"- **Increase MAX_PAGES** to get more data (be respectful of server load)\\n\",\n    \"- **Enable Selenium** if basic scraping doesn't work\\n\",\n    \"- **Modify custom analysis** functions in cells 11+ for your specific needs\\n\",\n    \"\\n\",\n    \"### Troubleshooting:\\n\",\n    \"- If no data is found, try setting `USE_SELENIUM=True`\\n\",\n    \"- Increase `DELAY_SECONDS` if you get rate-limited\\n\",\n    \"- Check that the AMAG website is accessible\\n\",\n    \"\\n\",\n    \"### Data Export:\\n\",\n    \"- CSV files are automatically exported and timestamped\\n\",\n    \"- Use the file browser on the left to download results\\n\",\n    \"- Files include both filtered and unfiltered data\\n\",\n    \"\\n\",\n    \"### Legal and Ethical Considerations:\\n\",\n    \"- This scraper includes respectful delays between requests\\n\",\n    \"- Always check website terms of service before scraping\\n\",\n    \"- Use scraped data responsibly and ethically\\n\",\n    \"- Consider reaching out to AMAG for official data access if needed\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"colab\": {\n   \"provenance\": []\n  },\n  \"kernelspec\": {\n   \"display_name\": \"Python 3\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"name\": \"python\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 0\n}
